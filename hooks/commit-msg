#!/bin/bash
#
# Git commit-msg hook for validating conventional commit format
# and encouraging multi-tag usage (aligned with EXTRACTION_PLAYBOOK.md)
#
# Self-installing: run directly to install, or git calls it automatically.
#
# Install:
#   ./hooks/commit-msg install
#
# Uninstall:
#   ./hooks/commit-msg uninstall

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# --- Self-install / uninstall mode (no $1 or $1 is "install"/"uninstall") ---
# Requirement: Combine setup.sh and commit-msg into a single file
# Approach: Detect install/uninstall subcommands; otherwise run as git hook
# Alternatives:
#   - Separate setup.sh: Rejected — two files for one concern, extra maintenance
#   - Makefile target: Rejected — adds tooling dependency for a simple copy
if [ "${1:-}" = "install" ] || [ "${1:-}" = "uninstall" ]; then
    # Find repo root (walk up from script location)
    REPO_ROOT="$SCRIPT_DIR"
    while [ "$REPO_ROOT" != "/" ] && [ ! -d "$REPO_ROOT/.git" ]; do
        REPO_ROOT="$(dirname "$REPO_ROOT")"
    done

    if [ ! -d "$REPO_ROOT/.git" ]; then
        echo "Error: Not inside a git repository."
        exit 1
    fi

    GIT_HOOKS_DIR="$REPO_ROOT/.git/hooks"

    if [ "$1" = "uninstall" ]; then
        if [ -f "$GIT_HOOKS_DIR/commit-msg" ]; then
            rm "$GIT_HOOKS_DIR/commit-msg"
            echo "Removed: commit-msg hook"
        else
            echo "Nothing to remove: commit-msg hook not installed"
        fi
        exit 0
    fi

    # Install
    echo "Installing git hooks..."

    SELF="$SCRIPT_DIR/commit-msg"
    cp "$SELF" "$GIT_HOOKS_DIR/commit-msg"
    chmod +x "$GIT_HOOKS_DIR/commit-msg"
    echo "  Installed: commit-msg hook"

    # Configure commit template if available
    if [ -f "$REPO_ROOT/.gitmessage" ]; then
        git config commit.template .gitmessage
        echo "  Configured: commit.template = .gitmessage"
    fi

    echo ""
    echo "Done! The commit-msg hook will validate your commit messages."
    echo ""
    echo "To bypass validation (not recommended):"
    echo "  git commit --no-verify"
    exit 0
fi

# --- Git hook mode ($1 is the commit message file path) ---

COMMIT_MSG_FILE="$1"
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

# Remove comments (lines starting with #)
COMMIT_MSG_CLEAN=$(echo "$COMMIT_MSG" | grep -v "^#")
FIRST_LINE=$(echo "$COMMIT_MSG_CLEAN" | head -1)

# Conventional commit pattern
# type(scope)!: subject OR type!: subject OR type(scope): subject OR type: subject
PATTERN="^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\([a-zA-Z0-9_-]+\))?(!)?: .{1,72}$"

# Check if first line matches pattern
if ! echo "$FIRST_LINE" | grep -qE "$PATTERN"; then
    echo ""
    echo "ERROR: Commit message does not follow conventional commit format."
    echo ""
    echo "Expected format: type(scope): subject"
    echo ""
    echo "Your message: $FIRST_LINE"
    echo ""
    echo "Valid types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert"
    echo ""
    echo "Examples:"
    echo "  feat(auth): add OAuth2 login support"
    echo "  fix(api): handle timeout errors"
    echo "  docs: update README"
    echo "  chore(deps): upgrade lodash"
    echo ""
    echo "See docs/COMMIT_CONVENTION.md for full guide."
    echo ""
    exit 1
fi

# Check subject length (already part of regex, but provide clearer error)
SUBJECT_LENGTH=$(echo "$FIRST_LINE" | wc -c)
if [ "$SUBJECT_LENGTH" -gt 73 ]; then
    echo ""
    echo "ERROR: Commit subject exceeds 72 characters ($SUBJECT_LENGTH chars)"
    echo ""
    echo "Your message: $FIRST_LINE"
    echo ""
    echo "Please shorten the subject line."
    echo ""
    exit 1
fi

# Warn about imperative mood (common mistakes)
SUBJECT=$(echo "$FIRST_LINE" | sed 's/^[^:]*: //')
if echo "$SUBJECT" | grep -qiE "^(added|adding|fixed|fixing|updated|updating|removed|removing|changed|changing) "; then
    echo ""
    echo "WARNING: Subject should use imperative mood."
    echo ""
    echo "Instead of: '$SUBJECT'"
    echo "Consider:   '$(echo "$SUBJECT" | sed -E 's/^(added|fixed|updated|removed|changed)/add/i; s/^(adding|fixing|updating|removing|changing)/add/i')'"
    echo ""
    echo "(Proceeding anyway - this is just a suggestion)"
    echo ""
fi

# Check for tags footer (warn if missing, don't block)
if ! echo "$COMMIT_MSG_CLEAN" | grep -qiE "^tags:"; then
    echo ""
    echo "TIP: Add a 'tags:' line with multiple tags for better analytics."
    echo ""
    echo "Example footer:"
    echo "  tags: feature, ui, ux"
    echo "  risk: low"
    echo "  debt: neutral"
    echo ""
    echo "See docs/EXTRACTION_PLAYBOOK.md for available tags."
    echo "(Proceeding without tags - this is optional but recommended)"
    echo ""
fi

# Check for risk/debt footers when tags are present (suggest, don't block)
if echo "$COMMIT_MSG_CLEAN" | grep -qiE "^tags:"; then
    if ! echo "$COMMIT_MSG_CLEAN" | grep -qiE "^risk:"; then
        echo "TIP: Consider adding 'risk: low|medium|high' for risk tracking."
    fi
    if ! echo "$COMMIT_MSG_CLEAN" | grep -qiE "^debt:"; then
        echo "TIP: Consider adding 'debt: added|paid|neutral' for debt tracking."
    fi
fi

exit 0
